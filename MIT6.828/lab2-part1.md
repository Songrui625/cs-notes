这个lab的主要任务是为JOS实现内存管理。内存管理包括两个组件： 1、供kernel使用的physical memory allocator。2、virtual memory。

<!-- more --> 

1、内核`物理内存分配器(physical memory allocator)`：内核用它来分配和释放内存。内存分配器会按`4KB`为单位来操作，这个单位称作`页(page)`。lab的任务是`维护一个数据结构`，记录哪个物理页已经分配，哪个物理页是可用的以及每个分配的页面共享多少个进程。  

2、`虚拟内存(Virtual Memory)`：由内核和用户程序将`虚拟地址`映射到`物理内存中的地址（物理地址）`。在x86中，当指令访问内存时，由硬件`内存管理单元（MMU）`执行映射，会查询一组`页表（Page Table）`，通过提供的规范来修改JOS以建立MMU的页表。  

Lab2包含了下面几个新的源文件：  

- `inc/memlayout.h`
- `kern/pmap.c`
- `kern/pmap.h`
- `kern/kclock.h`
- `kern/kclock.c`  

`memlayout.h`描述了虚拟地址空间的布局，我们得通过修改`pmap.c`来实现它, `memlayout.h`和`pmap.h`定义了结构体`PageInfo`（上文提到的需要维护的数据结构）来记录哪些物理页已经分配，哪些是可用的。  

`kclock.h`和`kclock.c`操纵PC的电池供电时钟和CMOS RAM硬件，BIOS在其中记录PC包含的物理内存大小以及其他东西。  

`pmap.c`的代码需要读取设备硬件来计算一共有多少物理内存，这个部分的代码已经提前为我们实现了，我们并不需要理解过多关于CMOS工作的细节。

我们需要额外注意的是`memlayout.h`和`pmap.h`，因为lab需要使用到以及理解里面包含的很多定义。可能还需要看一下`inc/mmu.h`,因为里面也包含了很多对本节lab有用的定义。

## Part1: Physical Page Management

> **Exercise1.** In the file `kern/pmap.c`, you must implement code for the following functions (probably in the order given).
>
> ```c
> boot_alloc()
> mem_init() (only up to the call to check_page_free_list(1))
> page_init()
> page_alloc()
> page_free()
> ```
>
> `check_page_free_list()` and `check_page_alloc()` test your physical page allocator. You should boot JOS and see whether `check_page_alloc()` reports success. Fix your code so that it passes. You may find it helpful to add your own `assert()`s to verify that your assumptions are correct.  

1、首先来实现`boot_alloc()`，源代码以及注释如下：

```c
 72 // This simple physical memory allocator is used only while JOS is setting
 73 // up its virtual memory system.  page_alloc() is the real allocator.
 74 //
 75 // If n>0, allocates enough pages of contiguous physical memory to hold 'n'
 76 // bytes.  Doesn't initialize the memory.  Returns a kernel virtual address.
 77 //
 78 // If n==0, returns the address of the next free page without allocating
 79 // anything.
 80 //
 81 // If we're out of memory, boot_alloc should panic.
 82 // This function may ONLY be used during initialization,
 83 // before the page_free_list list has been set up.
 84 static void *
 85 boot_alloc(uint32_t n)
 86 {
 87         static char *nextfree;  // virtual address of next byte of free memory
 88         char *result;
 89 
 90         // Initialize nextfree if this is the first time.
 91         // 'end' is a magic symbol automatically generated by the linker,
 92         // which points to the end of the kernel's bss segment:
 93         // the first virtual address that the linker did *not* assign
 94         // to any kernel code or global variables.
 95         if (!nextfree) {
 96                 extern char end[];
 97                 nextfree = ROUNDUP((char *) end, PGSIZE);
 98         }
 99 
100         // Allocate a chunk large enough to hold 'n' bytes, then update
101         // nextfree.  Make sure nextfree is kept aligned
102         // to a multiple of PGSIZE.
103         //
104         // LAB 2: Your code here.
112         return NULL;
113 }
```

这个函数的作用很简单，就是在没有建立真正的内存分配器之前，分配指定字节数的内存，返回下一个可用的地址（虚拟地址）。  

但是我觉得注释有点说的不清不楚，让我困惑了好久，可能是我比较菜的原因吧(T~T)。  

需要理解的几个点：`nextfree`, `end`，`ROUNDUP宏`, 参数`n`, `PGSIZE`，逐一解释：  

`nextfree`: 下一个可用的虚拟地址  。

`end`：函数里面的注释是 由链接器自动生成的魔数（magic symbol），指向内核 bss 段的末尾。而bss段的末尾就是第一个可用的虚拟地址，它没有被链接器分配给任何内核代码以及全局变量。**这里我是有疑惑的：为什么内核bss段的末尾就是第一个可用的虚拟地址？这是链接器那一块的知识，太菜了，不会。**

`PGSIZE`：4KB（4096 Byte）,一页的字节数，现代计算机里都是用字节寻址的，但是在内存管理中，都是按页作为单位，也就是说OS分配内存，都是分配几页几页，释放几页几页，而不是分配几个字节几个字节。并且页与页之间是`contiguous`的，也就是相邻的，第一页的最后一一个字节的下一个字节就是第二页的第一个字节。（这里请区别和malloc的不同，malloc允许用户分配指定字节大小的内存，但是其实OS会自动转换为分配为页的整数倍内存，何况我们现在还没有实现malloc）

`ROUNDUP`：向上取整为`PGSIZE`的倍数。由于内存分配是按页来做单位的，如果我们函数传进来的字节数不足一页（4KB），那如何计算呢？正是用`ROUNDUP`这个宏，详细定义在`inc/types.h`中。

`n`：需要分配的字节数，当n不是`PGSIZE`的整数倍时，需要用`ROUNDUP`宏进行取整。

理解了上面几个概念后就可以开始实现了, 查看下注释

```c
100  // Allocate a chunk large enough to hold 'n' bytes, then update
101  // nextfree.  Make sure nextfree is kept aligned
102  // to a multiple of PGSIZE.
```

其实这里提到的 `a chunk large enough to hold 'n' bytes`的意思就是分配 一个`PGSIZE`整数倍的块， 并且后面也有提示：`Make sure nextfree is kept aligned to a multiple of PGSIZE.`

实现如下：

```c
104         // LAB 2: Your code here.
     		// If n==0, returns the address of the next free page without allocating
 	  		// anything.
105         if (n == 0) return nextfree;
106         result = nextfree;
			// Allocate a chunk large enough to hold 'n' bytes, then update
	  		// nextfree. Make sure nextfree is kept aligned to a muliple of PGSIZE
107         nextfree += ROUNDUP(n, PGSIZE);
108 		// If we're out of memory, boot_alloc should panic
109         if ((nextfree - KERNBASE) >= 0x400000) {
110                 fprintf(stderr, "out of memory in address: %s\n", nextfree);
111         }
112         return result;
```

**这里我还有一些疑问：为什么是返回一个可用的虚拟地址（其实按理来说没问题，因为分配内存接口就是应该返回下一个可用内存的地址），不是说内核需要记录哪一些内存已经被使用了，哪些内存是可用的吗？那已经被使用的内存在哪里可以找到呢？我最初的想法是返回一个内核地址空间基地址（零地址），现在想想好像有点离谱,零地址是NULL**  

2、`mem_init()`：建立两级页表(**思考：为什么是需要两级页表？**)：`kern_pgdir`是根虚拟地址，即内核页表(页目录)，这个函数仅仅用来建立内核部分的地址空间。(ie. `address >= UTOP`)。用户部分的地址空间将在后面建立。从`UTOP`到`ULIM`的部分可以被用户读取但不能写入。`ULIM`地址以上的内容用户无法读取。  

我们看下这个函数具体是如何实现的：  

```c
void
mem_init(void)
{
	uint32_t cr0;
	size_t n;

	// Find out how much memory the machine has (npages & npages_basemem).
	i386_detect_memory();

	// Remove this line when you're ready to test this function.
	//panic("mem_init: This function is not finished\n");

	//////////////////////////////////////////////////////////////////////
	// create initial page directory. 
	kern_pgdir = (pde_t *) boot_alloc(PGSIZE);    //首先需要分配初始页目录，页目录本身大小为一页。而boot_alloc返回的是一个虚拟地址，所以kern_pgdir指向的是第一个虚拟地址。
	memset(kern_pgdir, 0, PGSIZE);                //这是一个uint32_t型数组，那一共PGSIZE大小，那么数组元素有多少个呢？那就是 PGSIZE / 4 = 1024个。

	//////////////////////////////////////////////////////////////////////
	// Recursively insert PD in itself as a page table, to form
	// a virtual page table at virtual address UVPT.
	// (For now, you don't have understand the greater purpose of the
	// following line.)

	// Permissions: kernel R, user R
	kern_pgdir[PDX(UVPT)] = PADDR(kern_pgdir) | PTE_U | PTE_P; // uvpt是一个虚拟页表，用户的权限为read-only。页目录本身也应该能被用户读取，知道去哪里寻找，所以采用了一种递归的方式来插入这一页，索引为什么是PDX(UVPT)呢？这样的意思就是，UVPT存放的是页目录在实际内存中的地址，但是一切地址映射都要在页表中，所以我们应该在页表中的某个元素来存储页目录的物理地址，但是又不能随便选一个来存储，所以我们选择PDX宏来完成。PDX宏会返回虚拟地址在页目录中的索引。

	//////////////////////////////////////////////////////////////////////
	// Allocate an array of npages 'struct PageInfo's and store it in 'pages'.
	// The kernel uses this array to keep track of physical pages: for
	// each physical page, there is a corresponding struct PageInfo in this
	// array.  'npages' is the number of physical pages in memory.  Use memset
	// to initialize all fields of each struct PageInfo to 0.
	// Your code goes here:
	pages = (struct PageInfo *) boot_alloc(npages * sizeof(struct PageInfo)); //第二个分配的存储物理页状态的struct PageInfo数组，数组的每一个元素代表一个物理页的状态，并不等同于实际的物理页，头文件有提供宏来从一个物理页状态定位到一个物理页地址。pages的首地址应该为kern_pgdir + 0x1000, 因为页目录本身大小占一页(4KB = 0x1000)。
	memset(pages, 0, npages * sizeof(struct PageInfo));
	//////////////////////////////////////////////////////////////////////
	// Now that we've allocated the initial kernel data structures, we set
	// up the list of free physical pages. Once we've done so, all further
	// memory management will go through the page_* functions. In
	// particular, we can now map memory using boot_map_region
	// or page_insert
	page_init();

	check_page_free_list(1);
```

3、接下来再看看`page_init()`：

```c

// --------------------------------------------------------------
// Tracking of physical pages.
// The 'pages' array has one 'struct PageInfo' entry per physical page.
// Pages are reference counted, and free pages are kept on a linked list.
// 每个物理页都有一个对应的struct PageInfo用来记录物理页的状态。
// 每页都是引用计数的，所有空闲页都可以在一个链表中，术语通常为空闲链表。
// --------------------------------------------------------------

//
// Initialize page structure and memory free list. 
// After this is done, NEVER use boot_alloc again.  ONLY use the page
// allocator functions below to allocate and deallocate physical
// memory via the page_free_list.
//
void
page_init(void)
{
	// The example code here marks all physical pages as free.
	// However this is not truly the case.  What memory is free?
	//  1) Mark physical page 0 as in use.
	//     This way we preserve the real-mode IDT and BIOS structures
	//     in case we ever need them.  (Currently we don't, but...)
	//  2) The rest of base memory, [PGSIZE, npages_basemem * PGSIZE)
	//     is free.
	//  3) Then comes the IO hole [IOPHYSMEM, EXTPHYSMEM), which must
	//     never be allocated.
	//  4) Then extended memory [EXTPHYSMEM, ...).
	//     Some of it is in use, some is free. Where is the kernel
	//     in physical memory?  Which pages are already in use for
	//     page tables and other data structures?
	//
	// Change the code to reflect this.
	// NB: DO NOT actually touch the physical memory corresponding to
	// free pages!
	size_t i;
	for (i = 0; i < npages; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
}
```

样例代码把所有物理页都标记为空闲的，很显然是不对的。

1）标记物理页0为 正在使用的：这是为实模式的`IDT`(中断描述符表:`Interrupt Descriptor Table`)保留的和在某些情况下需要用到的BIOS。  

2）剩余的`base memory`， [PGSIZE, npages_basemem * PGSIZE）是空闲的。  

3）然后是`IO hole`[IOPHYSMEM, EXTPHYSMEM）,这部分是不允许分配到。  

4) 然后是`extended memory`[EXTPHYSMEM, ...)有些是空闲的，有些却是正在使用的。内核存在于物理内存的哪里呢？哪些页面已经被页表和其他数据结构使用？  

这四个问题需要对虚拟内存的布局和物理内存布局有一个清晰的认识。我们回顾一下lab1的物理内存布局：   

![image-20210309195849822](.\figure\image-20210309195849822.png)

Low Memory也就是上面提到的 base memory。在`pmap.c`中的`detect_memory()`函数中打印了base memory一共有多大。

```bash
Physical memory: 131072K available, base = 640K, extended = 130432K
```

所以npages_basemem（base memory一共所占的页面数） = 640KB / PGSIZE = 160。  

在`memlayout.h`中可以看到: 

```c
#define IOPHYSMEM	0x0A0000
#define EXTPHYSMEM	0x100000
```

对应物理内存布局图，应该可以明白为什么[IOPHYSMEM, EXTPHYSMEM）这部分内存不允许分配，被称作`IO hole`，这部分内存用于`VGA Display`、`devices ROMS`以及`BIOS ROM`。  

如果认真的做过lab1，应该记得kernel被装载到了物理内存中的什么位置: we will use the processor's memory management hardware to map virtual address 0xf0100000 (the link address at which the kernel code *expects* to run) to physical address `0x00100000` (where the boot loader loaded the kernel into physical memory)  

所以`0x00100000`就是内核被装载进物理内存中的地址，也正是`Extended Memory`的起始地址，那哪些页面已经被内核、页表和其他数据结构使用了呢？  

回顾一下`boot_alloc（）`里面的魔术`end`指向了内核的bss段末尾，而我们又分配了页面给`kern_pgdir`和`pages`，下一个空闲的页面的虚拟地址就是`boot_alloc(0)`，`boot_alloc(0)`的返回值之前的页面就是已经被内核、页表(`kern_pgdir`)和其他数据结构(`struct PageInfo`)使用了的页面。

我们这里在总结下lab1中的物理内存布局： 

<img src=".\figure\1E86FC826CB074342E4AB486F0DD7EF1.png" alt="img" style="zoom: 50%;" />

弄清楚了内存布局以及哪些页面是空闲的，哪些是正在使用的，就可以来实现代码了。

```c
	size_t i;
	// 第一页要保存实模式下的IDT。
	pages[0].pp_ref = 1;
	pages[0].pp_link = NULL;
	
	//base memory剩下的159页，都可以使用，利用头插法插入空闲页面。
	for (i = 1; i < npages_basemem; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
	// IO hole是不能被分配的，标记为正在使用。
	for (i = IOPHYSMEM / PGSIZE; i < EXTPHYSMEM / PGSIZE; i++) {
		pages[i].pp_ref = 1;
		pages[i].pp_link = NULL;
	}
	//注意，pages数组存储的是物理内存中每一页的状态，所以对应的索引应该是 物理地址 / PGSIZE;
	//而boot_alloc(0)返回的是一个虚拟地址，需要用PADDR宏转换为物理地址。
	size_t free_idx = PADDR(boot_alloc(0)) / PGSIZE;
	//内核代码的页面直到free_idx之前页面都是已经使用过的。
	for (i = EXTPHYSMEM / PGSIZE; i < free_idx; i++) {
		pages[i].pp_ref = 1;
		pages[i].pp_link = NULL;
	}
	//free_idx后面的页面都是空闲的。
	for (i = free_idx; i < npages; i++) {
		pages[i].pp_ref = 0;
		pages[i].pp_link = page_free_list;
		page_free_list = &pages[i];
	}
```

4、`page_alloc()`：参数：alloc_flag，是否把分配的物理页内容全部置为0。 返回值：分配物理页的对应PageInfo结构体指针。

```c
//
// Allocates a physical page.  If (alloc_flags & ALLOC_ZERO), fills the entire
// returned physical page with '\0' bytes.  Does NOT increment the reference
// count of the page - the caller must do these if necessary (either explicitly
// or via page_insert).
//
// Be sure to set the pp_link field of the allocated page to NULL so
// page_free can check for double-free bugs.
//
// Returns NULL if out of free memory.
//
// Hint: use page2kva and memset
struct PageInfo *
page_alloc(int alloc_flags)
{
	// Fill this function in
	if (!page_free_list) return NULL;
	struct PageInfo *ret = page_free_list;
	page_free_list = page_free_list->pp_link;
	ret->pp_link = NULL;
	if (alloc_flags & ALLOC_ZERO) {
		memset(page2kva(ret), 0, PGSIZE);
	}
	return ret;
}
```

注释已经说的很明白了，分配一个物理页，首先，这个物理页肯定是空闲的，我们可以从空闲列表中拿到，从头部拿就可以了，效率高，从尾部拿需要遍历整个链表。  

拿到之后，不需要设置引用计数，如果alloc_flag为ALLOC_ZERO，那就把这个物理页的虚拟地址内容全部置为0, 因为C语言中的地址的值是随机的（如果不初始化）。

5、`page_free()`：参数：需要释放页面的PageInfo结构指针。

```c
//
// Return a page to the free list.
// (This function should only be called when pp->pp_ref reaches 0.)
//
void
page_free(struct PageInfo *pp)
{
	// Fill this function in
	// Hint: You may want to panic if pp->pp_ref is nonzero or
	// pp->pp_link is not NULL.
	if (pp->pp_ref != 0 || pp->pp_link != NULL) {
		panic("page_free: pp->pp_ref is nonzero or pp->pp_link is not NULL\n");
	}
	pp->pp_link = page_free_list;
	page_free_list = pp;
}
```

看着注释应该很好理解。就利用头插法插入释放的页面。需要检查一下引用计数是否为0。  

至此，Part1就已经完成了。



